# Automatic Build-Time Code Generation for Zoop

## Overview

Zoop uses **automatic build-time code generation** to provide flat-namespace method access with configurable prefixes. The code generation runs automatically during every compilation - you never need to manually run a build step.

## How It Works

### 1. You Write Class Definitions

```zig
// src/my_classes.zig
const zoop = @import("zoop");

const Parent = zoop.class(struct {
    value: u32,
    
    pub fn getValue(self: *Parent) u32 {
        return self.value;
    }
    
    pub fn setValue(self: *Parent, v: u32) void {
        self.value = v;
    }
});

const Child = zoop.class(struct {
    pub const extends = Parent;
    
    // Configure method prefixes (optional)
    pub const config = zoop.ClassConfig{
        .method_prefix = "call_",  // Default
        .getter_prefix = "get_",   // Default
        .setter_prefix = "set_",   // Default
    };
    
    pub const properties = .{
        .name = .{
            .type = []const u8,
            .access = .read_write,
            .default = "",
        },
    };
    
    age: u8,
    
    // Override parent method
    pub fn getValue(self: *Child) u32 {
        return self.value * 2;
    }
});
```

### 2. Build System Automatically Generates Code

When you run `zig build`, `zig build run`, `zig build test`, or any other build command:

1. **Class generation step runs first**
2. **Scans `src/` for class definitions**
3. **Generates enhanced structs** in `zig-cache/generated/`
4. **Compilation uses generated code**

Generated file: `zig-cache/generated/my_classes.zig`

```zig
// Auto-generated by Zoop build system
// DO NOT EDIT - changes will be overwritten

const std = @import("std");

pub const Parent = struct {
    value: u32,
    
    pub inline fn call_getValue(self: *Parent) u32 {
        return self.value;
    }
    
    pub inline fn call_setValue(self: *Parent, v: u32) void {
        self.value = v;
    }
};

pub const Child = struct {
    // Parent fields (never reordered)
    value: u32,
    
    // Property backing fields (sorted by alignment)
    age: u8,
    _name: []const u8 = "",
    
    // Parent methods with configured prefix (only if not overridden)
    // call_getValue is NOT generated because Child overrides it
    
    pub inline fn call_setValue(self: *Child, v: u32) void {
        self.value = v;
    }
    
    // Property getters/setters with configured prefixes
    pub inline fn get_name(self: *Child) []const u8 {
        return self._name;
    }
    
    pub inline fn set_name(self: *Child, value: []const u8) void {
        self._name = value;
    }
    
    // Child's own methods (copied as-is)
    pub fn getValue(self: *Child) u32 {
        return self.value * 2;
    }
};
```

### 3. You Use The Generated Classes

```zig
const std = @import("std");
const classes = @import("my_classes.zig");

pub fn main() !void {
    var child = classes.Child{
        .value = 21,
        .age = 42,
    };
    
    // Use inherited method with prefix
    child.call_setValue(100);
    
    // Use overridden method (no prefix, it's child's own)
    const doubled = child.getValue();
    
    // Use property with configured prefix
    child.set_name("Alice");
    const name = child.get_name();
    
    std.debug.print("Value: {}, Name: {s}\n", .{ doubled, name });
}
```

## Workflow

```
┌─────────────────────┐
│ You edit source     │
│ (src/*.zig)         │
└──────────┬──────────┘
           │
           ├─ zig build
           │  zig build run
           │  zig build test
           │  zig test
           │  etc.
           │
           v
┌─────────────────────┐
│ Class Gen Step      │◄─ Runs AUTOMATICALLY
│ Scans src/          │   (you don't invoke it)
│ Finds class()       │
│ calls               │
└──────────┬──────────┘
           │
           │ Generates
           v
┌─────────────────────┐
│ zig-cache/generated/│
│ my_classes.zig      │
│ other_classes.zig   │
└──────────┬──────────┘
           │
           │ Imports
           v
┌─────────────────────┐
│ Your code compiles  │
│ with generated      │
│ classes             │
└─────────────────────┘
```

## Configuration Options

### Global Defaults (Recommended)

```zig
// src/zoop_config.zig
pub const default_config = zoop.ClassConfig{
    .method_prefix = "call_",
    .getter_prefix = "get_",
    .setter_prefix = "set_",
};
```

### Per-Class Configuration

```zig
const MyClass = zoop.class(struct {
    pub const config = zoop.ClassConfig{
        .method_prefix = "",        // No prefix for methods
        .getter_prefix = "",        // No prefix for getters
        .setter_prefix = "update_", // Custom prefix for setters
    };
    
    // ...
});
```

## Override Detection

The build system automatically detects when a child overrides a parent method:

```zig
const Parent = zoop.class(struct {
    pub fn foo(self: *Parent) void { }
    pub fn bar(self: *Parent) void { }
});

const Child = zoop.class(struct {
    pub const extends = Parent;
    
    // Override foo - NO call_foo generated
    pub fn foo(self: *Child) void {
        // Custom implementation
    }
    
    // Don't override bar - call_bar IS generated
});
```

Generated:
```zig
pub const Child = struct {
    // call_foo NOT generated (overridden)
    
    pub inline fn call_bar(self: *Child) void {
        // Generated wrapper
    }
    
    pub fn foo(self: *Child) void {
        // Child's implementation
    }
};
```

## Incremental Compilation

The build system uses file hashes to detect changes:

- **Source unchanged**: Skip regeneration (fast)
- **Source changed**: Regenerate only affected classes
- **No manual cache clearing needed**

## Benefits

1. ✅ **Automatic**: Runs every compilation
2. ✅ **Flat namespace**: `child.call_getValue()` not `child.parent.getValue()`
3. ✅ **Configurable prefixes**: Per-class or global
4. ✅ **Override detection**: No duplicate methods
5. ✅ **Zero runtime cost**: Everything inlined
6. ✅ **Type safe**: Compile-time guarantees
7. ✅ **Works with Zig 0.15+**: No `usingnamespace` needed

## Debugging Generated Code

Generated files are in `zig-cache/generated/`:

```bash
# View generated code
cat zig-cache/generated/my_classes.zig

# Force regeneration
zig build --clean

# Verbose generation
zig build -Dverbose=true
```

## Integration with LSP

Your editor's Zig LSP will automatically understand the generated code because:

1. Generated files are in the module path
2. Build system ensures they exist before LSP analysis
3. Imports work normally

## Next Steps

This document describes the architecture. The actual implementation requires:

1. Completing `build_codegen.zig` with full AST parsing
2. Implementing method signature extraction
3. Handling all edge cases (generics, errors, etc.)
4. Adding tests for code generation
5. Documentation for users

See `build_codegen.zig` for implementation details.
