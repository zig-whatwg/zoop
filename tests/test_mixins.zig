// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

const std = @import("std");

// Mixin 1: Timestamped
pub const Timestamped = struct {
    created_at: i64,
    updated_at: i64,

    pub fn updateTimestamp(self: *Timestamped) void {
        self.updated_at = std.time.timestamp();
    }
    pub fn getAge(self: *const Timestamped) i64 {
        return std.time.timestamp() - self.created_at;
    }
};


// Mixin 2: Serializable
pub const Serializable = struct {
    pub fn toJson(self: *const Serializable, allocator: std.mem.Allocator) ![]const u8 {
        _ = self;
        return try allocator.dupe(u8, "{}");
    }
};


// Base class
pub const Entity = struct {
    id: u64,

    pub fn save(self: *Entity) void {
        std.debug.print("Saving entity {}\n", .{self.id});
    }
};


// Class with parent AND mixins
pub const User = struct {
    super: Entity,

    created_at: i64,
    updated_at: i64,

    name: []const u8,
    email: []const u8,

    pub fn greet(self: *const User) void {
        std.debug.print("Hello, I'm {s}\n", .{self.name});
    }

    pub inline fn call_save(self: *User) void {
        self.super.save();
    }

    pub fn updateTimestamp(self: *User) void {
        self.updated_at = std.time.timestamp();
    }
    pub fn getAge(self: *const User) i64 {
        return std.time.timestamp() - self.created_at;
    }
    pub fn toJson(self: *const User, allocator: std.mem.Allocator) ![]const u8 {
        _ = self;
        return try allocator.dupe(u8, "{}");
    }
};


test "mixin fields are flattened into child class" {
    const allocator = std.testing.allocator;

    const user = User{
        .super = Entity{ .id = 1 },
        // Mixin fields should be directly accessible
        .created_at = 1000,
        .updated_at = 2000,
        // Own fields
        .name = "Alice",
        .email = "alice@example.com",
    };

    try std.testing.expectEqual(@as(u64, 1), user.super.id);
    try std.testing.expectEqual(@as(i64, 1000), user.created_at);
    try std.testing.expectEqual(@as(i64, 2000), user.updated_at);
    try std.testing.expectEqualStrings("Alice", user.name);

    _ = allocator;
}

test "mixin methods are copied into child class" {
    var user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    // Mixin method should be available directly
    user.updateTimestamp();

    // Check that timestamp was updated (should be > 2000)
    try std.testing.expect(user.updated_at > 2000);
}

test "parent methods still work with mixins" {
    var user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    // Parent method should still be available via call_ prefix
    user.call_save();
}

test "child can override mixin methods" {
    // Test that child methods take precedence over mixin methods
    // This is verified by the code generation - child methods in parsed.methods
    // will not be generated again from mixins due to child_method_names check
    try std.testing.expect(true);
}

test "multiple mixins with different methods" {
    const user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    const allocator = std.testing.allocator;

    // Method from Timestamped mixin
    const age = user.getAge();
    try std.testing.expect(age > 0);

    // Method from Serializable mixin
    const json = try user.toJson(allocator);
    defer allocator.free(json);
    try std.testing.expectEqualStrings("{}", json);
}
