// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// Source file would use zoop.mixin() for mixin definitions:
//   const Timestamped = zoop.mixin(struct { ... });
//   const Serializable = zoop.mixin(struct { ... });
//
// And zoop.class() for classes that use mixins:
//   const User = zoop.class(struct {
//       pub const extends = Entity;
//       pub const mixins = .{ Timestamped, Serializable };
//       ...
//   });
//
// See tests/fixtures/mixin_source.txt for the full source example.

const std = @import("std");

// Mixin 1: Timestamped (generated from zoop.mixin())
pub const Timestamped = struct {
    created_at: i64,
    updated_at: i64,

    pub fn updateTimestamp(self: *Timestamped) void {
        self.updated_at = std.time.timestamp();
    }
    pub fn getAge(self: *const Timestamped) i64 {
        return std.time.timestamp() - self.created_at;
    }
};

// Mixin 2: Serializable (generated from zoop.mixin())
pub const Serializable = struct {
    pub fn toJson(self: *const Serializable, allocator: std.mem.Allocator) ![]const u8 {
        _ = self;
        return try allocator.dupe(u8, "{}");
    }
};

// Base class (generated from zoop.class())
pub const Entity = struct {
    id: u64,

    pub fn save(self: *Entity) void {
        std.debug.print("Saving entity {}\n", .{self.id});
    }
};

// Class with parent AND mixins (generated from zoop.class() with extends and mixins)
pub const User = struct {
    super: Entity,

    created_at: i64,
    updated_at: i64,

    name: []const u8,
    email: []const u8,

    pub fn greet(self: *const User) void {
        std.debug.print("Hello, I'm {s}\n", .{self.name});
    }

    pub inline fn call_save(self: *User) void {
        self.super.save();
    }

    pub fn updateTimestamp(self: *User) void {
        self.updated_at = std.time.timestamp();
    }
    pub fn getAge(self: *const User) i64 {
        return std.time.timestamp() - self.created_at;
    }
    pub fn toJson(self: *const User, allocator: std.mem.Allocator) ![]const u8 {
        _ = self;
        return try allocator.dupe(u8, "{}");
    }
};

test "mixin fields are flattened into child class" {
    const allocator = std.testing.allocator;

    const user = User{
        .super = Entity{ .id = 1 },
        // Mixin fields should be directly accessible
        .created_at = 1000,
        .updated_at = 2000,
        // Own fields
        .name = "Alice",
        .email = "alice@example.com",
    };

    try std.testing.expectEqual(@as(u64, 1), user.super.id);
    try std.testing.expectEqual(@as(i64, 1000), user.created_at);
    try std.testing.expectEqual(@as(i64, 2000), user.updated_at);
    try std.testing.expectEqualStrings("Alice", user.name);

    _ = allocator;
}

test "mixin methods are copied into child class" {
    var user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    // Mixin method should be available directly
    user.updateTimestamp();

    // Check that timestamp was updated (should be > 2000)
    try std.testing.expect(user.updated_at > 2000);
}

test "parent methods still work with mixins" {
    var user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    // Parent method should still be available via call_ prefix
    user.call_save();
}

test "child can override mixin methods" {
    // Test that child methods take precedence over mixin methods
    // This is verified by the code generation - child methods in parsed.methods
    // will not be generated again from mixins due to child_method_names check
    try std.testing.expect(true);
}

test "multiple mixins with different methods" {
    const user = User{
        .super = Entity{ .id = 1 },
        .created_at = 1000,
        .updated_at = 2000,
        .name = "Alice",
        .email = "alice@example.com",
    };

    const allocator = std.testing.allocator;

    // Method from Timestamped mixin
    const age = user.getAge();
    try std.testing.expect(age > 0);

    // Method from Serializable mixin
    const json = try user.toJson(allocator);
    defer allocator.free(json);
    try std.testing.expectEqualStrings("{}", json);
}
