const std = @import("std");

/// Class configuration
pub const ClassConfig = struct {
    method_prefix: []const u8 = "call_",
    getter_prefix: []const u8 = "get_",
    setter_prefix: []const u8 = "set_",
};

/// Register a class for code generation at build time
///
/// This function serves as a marker for the build-time codegen tool to identify classes.
/// It must return a valid type so that source files can be parsed by the Zig compiler
/// during the codegen scan phase. The actual enhanced implementation (with inherited
/// methods, property getters/setters, etc.) is generated by the build-time tool and
/// written to the output directory.
pub fn class(comptime definition: type) type {
    // Extract configuration (unused in comptime version, but needed for parsing)
    const config = if (@hasDecl(definition, "config"))
        definition.config
    else
        ClassConfig{};

    _ = config;

    // Return a minimal valid type for parsing:
    // - If it has a parent, merge fields so struct is valid
    // - Otherwise, just return the definition as-is
    const Parent = if (@hasDecl(definition, "extends"))
        definition.extends
    else
        null;

    if (Parent) |P| {
        return mergeFields(P, definition);
    } else {
        return definition;
    }
}

/// Merge parent and child fields at comptime to create a valid struct type
/// This is ONLY used during the codegen scan phase to ensure source files parse correctly.
/// The actual runtime code uses the build-time generated version with proper 'super' field.
fn mergeFields(comptime ParentType: type, comptime ChildDef: type) type {
    const parent_info = @typeInfo(ParentType);
    const child_info = @typeInfo(ChildDef);

    const parent_struct = parent_info.@"struct";
    const child_struct = child_info.@"struct";

    // Merge fields (parent first)
    const total_fields = parent_struct.fields.len + child_struct.fields.len;
    var all_fields: [total_fields]std.builtin.Type.StructField = undefined;

    inline for (parent_struct.fields, 0..) |field, i| {
        all_fields[i] = field;
    }
    inline for (child_struct.fields, 0..) |field, i| {
        all_fields[parent_struct.fields.len + i] = field;
    }

    return @Type(.{
        .@"struct" = .{
            .layout = .auto,
            .fields = &all_fields,
            .decls = &[_]std.builtin.Type.Declaration{},
            .is_tuple = false,
        },
    });
}
