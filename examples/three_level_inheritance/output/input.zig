// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
//
// This file was generated from the source file with the same name.
// Class definitions have been enhanced with:
//   - Inherited methods from parent classes
//   - Property getters and setters
//   - Optimized field layouts

const std = @import("std");

// Level 1: Base class with custom init validation
pub const Entity = struct {
    allocator: std.mem.Allocator,

    id: u64,
    pub fn init(allocator: std.mem.Allocator, id: u64) !Entity {
        // Custom validation logic
        if (id == 0) return error.InvalidId;
        if (id > 999999) return error.IdTooLarge;

        std.debug.print("[Entity.init] Creating entity with id={}\n", .{id});

        return try Entity.initFields(allocator, &.{
            .id = id,
        });
    }
    fn initFields(allocator: std.mem.Allocator, fields: *const struct { id: u64 }) !Entity {
        return .{
            .allocator = allocator,
            .id = fields.id,
        };
    }

    pub inline fn get_id(self: *const @This()) u64 {
        return self.id;
    }
};


// Level 2: Named entity adds a name field
pub const NamedEntity = struct {
    allocator: std.mem.Allocator,

    id: u64,

    name: []const u8,
    pub fn init(allocator: std.mem.Allocator, id: u64, name: []const u8) !NamedEntity {

        // Custom validation logic
        if (id == 0) return error.InvalidId;
        if (id > 999999) return error.IdTooLarge;

        std.debug.print("[Entity.init] Creating entity with id={}\n", .{id});

        return try NamedEntity.initFields(allocator, &.{
            .id = id,
            .name = name});
        }

    fn initFields(allocator: std.mem.Allocator, fields: *const struct { name: []const u8, id: u64, }) !NamedEntity {
        return NamedEntity{
            .allocator = allocator,
            .name = try allocator.dupe(u8, fields.name),
            .id = fields.id,
        };
    }
    pub fn deinit(self: *NamedEntity) void {
        self.allocator.free(self.name);
    }
};


// Level 3: User adds email and active status
pub const User = struct {
    allocator: std.mem.Allocator,

    name: []const u8,
    id: u64,

    email: []const u8,
    active: bool,
    pub fn init(allocator: std.mem.Allocator, id: u64, name: []const u8, active: bool, email: []const u8) !User {

        // Custom validation logic
        if (id == 0) return error.InvalidId;
        if (id > 999999) return error.IdTooLarge;

        std.debug.print("[Entity.init] Creating entity with id={}\n", .{id});

        return try User.initFields(allocator, &.{
            .id = id,
            .name = name,
            .active = active,
            .email = email});
        }

    fn initFields(allocator: std.mem.Allocator, fields: *const struct { name: []const u8, active: bool, id: u64, email: []const u8, }) !User {
        return User{
            .allocator = allocator,
            .name = try allocator.dupe(u8, fields.name),
            .active = fields.active,
            .id = fields.id,
            .email = try allocator.dupe(u8, fields.email),
        };
    }
    pub fn deinit(self: *User) void {
        self.allocator.free(self.name);
        self.allocator.free(self.email);
    }

    pub inline fn get_email(self: *const @This()) []const u8 {
        return self.email;
    }
    pub inline fn set_email(self: *@This(), value: []const u8) void {
        self.email = value;
    }
};

