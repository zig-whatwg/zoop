# Zoop Workflow - Developing Libraries with Zoop

This skill teaches you how to develop Zig libraries using Zoop's object-oriented code generation system.

---

## ⚠️ STRICT RULES - READ FIRST

### Rule #1: NEVER Edit Generated Files

**Generated files** live in the output directory (typically `src/`). These files have this header:

```zig
// Auto-generated by zoop-codegen
// DO NOT EDIT - changes will be overwritten
```

**YOU MUST NEVER EDIT THESE FILES.** Any changes will be lost on the next build.

**ONLY edit files in the source directory** (typically `zoop_src/`).

If you see a bug in generated code:
1. ❌ DO NOT edit the generated file
2. ✅ Edit the zoop source file
3. ✅ Run `zig build` to regenerate
4. ✅ Verify the fix in the generated output

**This rule has NO exceptions.**

---

## What is Zoop?

Zoop is a **build-time code generator** for Zig that adds object-oriented programming features:

- **Inheritance** - Classes can extend other classes
- **Properties** - Auto-generated getters/setters
- **Mixins** - Multiple inheritance via composition
- **Zero runtime cost** - All code is inlined, compiles to direct calls

**Key concept**: You write class definitions in source files, and zoop-codegen generates enhanced Zig structs at build time.

---

## Project Structure

A typical zoop project has this structure:

```
myproject/
├── zoop_src/              ← SOURCE OF TRUTH - EDIT THESE FILES
│   ├── user.zig
│   ├── admin.zig
│   └── ...
│
├── src/                   ← GENERATED - DO NOT EDIT
│   ├── user.zig          (auto-generated from zoop_src/user.zig)
│   ├── admin.zig         (auto-generated from zoop_src/admin.zig)
│   └── main.zig          (your entry point - not generated)
│
├── .zig-cache/
│   └── zoop-manifest.json (cache - gitignore this)
│
├── build.zig             (configures source_dir and output_dir)
└── build.zig.zon
```

**Finding the directories:**

Check `build.zig` for the zoop configuration:
```zig
const zoop_step = zoop.addZoopCodegen(b, .{
    .source_dir = "zoop_src",  // ← Source files here
    .output_dir = "src",        // ← Generated files here
});
```

If the project uses default conventions and no config is explicit:
- Source: `zoop_src/`
- Output: `src/`

---

## Development Cycle

### Step 1: Edit Zoop Source Files

Make changes to files in `zoop_src/`:

```zig
// zoop_src/user.zig
const std = @import("std");
const zoop = @import("zoop");

pub const User = zoop.class(struct {
    pub const properties = .{
        .email = .{
            .type = []const u8,
            .access = .read_write,
        },
        .id = .{
            .type = u64,
            .access = .read_only,
        },
    };

    name: []const u8,
    
    pub fn init(allocator: std.mem.Allocator, name: []const u8, email: []const u8, id: u64) !User {
        return User.initFields(allocator, &.{
            .name = name,
            .email = email,
            .id = id,
        });
    }
});
```

### Step 2: Build (Auto-Regenerates)

```bash
zig build
```

The build system automatically:
1. Runs zoop-codegen
2. Checks cache for changes
3. Regenerates files that changed + their descendants
4. Compiles the generated code

### Step 3: Run Tests

```bash
zig build test
```

Tests compile against the **generated** files in `src/`.

### Step 4: Review Changes

```bash
git diff zoop_src/user.zig  # Your changes
git diff src/user.zig       # What zoop generated
```

### Step 5: Format and Verify

```bash
zig fmt --check src/ zoop_src/ tests/
```

**CRITICAL**: Always run `zig fmt --check` before committing. If it fails, run `zig fmt` to fix formatting.

### Step 6: Commit Both

```bash
git add zoop_src/user.zig src/user.zig
git commit -m "Add email property to User"
```

**Always commit both source and generated files in the same commit.**

---

## Understanding Zoop Architecture

### Class Declaration

```zig
pub const User = zoop.class(struct {
    // Fields
    name: []const u8,
    age: u32,
    
    // Methods
    pub fn greet(self: *User) void {
        std.debug.print("Hello, {s}\n", .{self.name});
    }
});
```

### Inheritance

```zig
pub const Admin = zoop.class(struct {
    pub const extends = User;  // ← Inheritance
    
    permissions: []const u8,
    
    pub fn manageUsers(self: *Admin) void {
        // Can access User fields directly
        std.debug.print("Admin {s} managing users\n", .{self.name});
    }
});
```

**Generated code** (conceptual - actual implementation details differ):
```zig
pub const Admin = struct {
    // Parent fields are flattened (no .super field)
    name: []const u8,
    age: u32,
    
    // Child fields
    permissions: []const u8,
    
    // Child methods
    pub fn manageUsers(self: *Admin) void { /* ... */ }
    
    // Inherited methods (copied and rewritten)
    pub fn greet(self: *Admin) void {
        std.debug.print("Hello, {s}\n", .{self.name});
    }
};
```

**Key points:**
- Fields are **flattened** (no `.super` field)
- Methods are **copied** from parent
- Everything is **inlined** (zero runtime cost)

### Properties

```zig
pub const properties = .{
    .email = .{
        .type = []const u8,
        .access = .read_write,  // or .read_only
    },
};
```

Generates:
```zig
pub inline fn get_email(self: *const User) []const u8 {
    return self.email;
}

pub inline fn set_email(self: *User, value: []const u8) void {
    self.email = value;
}
```

### Mixins

```zig
pub const Timestamped = zoop.mixin(struct {
    created_at: i64,
    updated_at: i64,
});

pub const User = zoop.class(struct {
    pub const mixins = .{ Timestamped };
    
    name: []const u8,
});
```

Mixin fields/methods are **flattened** into the class.

---

## Cache System

### How It Works

Zoop maintains a cache manifest in `.zig-cache/zoop-manifest.json` that tracks:
- **Content hash** (SHA-256) of each source file
- **Modification timestamp** for quick checks
- **Class names** defined in each file
- **Parent classes** for dependency tracking

### Cache Behavior

**First build:**
```
Processed 10 files, generated 10 class files
```

**Second build (no changes):**
```
Processed 10 files, generated 0 class files  ⚡ Fast!
```

**After modifying a parent class:**
```
Processed 10 files, generated 5 class files  (parent + 4 descendants)
```

### Descendant Tracking

When you modify a parent class, **all descendants are automatically regenerated**.

Example hierarchy:
```
User
├─ Admin
│  └─ SuperAdmin
└─ Moderator
```

If you edit `zoop_src/user.zig`, zoop regenerates:
- `src/user.zig`
- `src/admin.zig`
- `src/superadmin.zig`
- `src/moderator.zig`

### Clearing the Cache

If the cache becomes corrupted or you need to force full regeneration:

```bash
zig build clean-cache  # If build.zig has this step
# OR
rm .zig-cache/zoop-manifest.json
zig build
```

**When to clear cache:**
- After updating zoop-codegen binary
- After changing build.zig configuration
- If you suspect cache corruption
- For troubleshooting unexplained issues

---

## Common Tasks Quick Reference

| Task | Command | Files to Edit |
|------|---------|---------------|
| Add new class | Create `zoop_src/myclass.zig` | `zoop_src/myclass.zig` |
| Add field to class | Edit source file, add field | `zoop_src/user.zig` |
| Add method to class | Edit source file, add method | `zoop_src/user.zig` |
| Add property | Edit source file, add to `.properties` | `zoop_src/user.zig` |
| Create child class | Create new file with `extends = Parent` | `zoop_src/child.zig` |
| Override method | Define method with same name in child | `zoop_src/admin.zig` |
| Build project | `zig build` | N/A |
| Run tests | `zig build test` | N/A |
| Check formatting | `zig fmt --check src/ zoop_src/ tests/` | N/A |
| Fix formatting | `zig fmt src/ zoop_src/ tests/` | N/A |
| Force regeneration | `zig build clean-cache` then `zig build` | N/A |
| Check what changed | `git diff src/` | N/A |

---

## Complete Example: User/Admin System

This example shows creating a User base class and an Admin child class.

### File: `zoop_src/user.zig`

```zig
const std = @import("std");
const zoop = @import("zoop");

pub const User = zoop.class(struct {
    pub const properties = .{
        .email = .{
            .type = []const u8,
            .access = .read_write,
        },
    };

    name: []const u8,
    
    pub fn init(allocator: std.mem.Allocator, name: []const u8, email: []const u8) !User {
        return User.initFields(allocator, &.{
            .name = name,
            .email = email,
        });
    }
    
    pub fn deinit(self: *User) void {
        self.allocator.free(self.name);
        self.allocator.free(self.email);
    }
    
    pub fn authenticate(self: *User, password: []const u8) bool {
        _ = self;
        _ = password;
        // Implementation
        return true;
    }
});
```

### File: `zoop_src/admin.zig`

```zig
const std = @import("std");
const zoop = @import("zoop");
const User = @import("user.zig").User;

pub const Admin = zoop.class(struct {
    pub const extends = User;
    
    role: []const u8,
    
    pub fn init(allocator: std.mem.Allocator, name: []const u8, email: []const u8, role: []const u8) !Admin {
        return Admin.initFields(allocator, &.{
            .name = name,
            .email = email,
            .role = role,
        });
    }
    
    pub fn deinit(self: *Admin) void {
        self.allocator.free(self.name);
        self.allocator.free(self.email);
        self.allocator.free(self.role);
    }
    
    pub fn manageUsers(self: *Admin) void {
        std.debug.print("Admin {s} managing users\n", .{self.name});
    }
});
```

### Using the Classes

```zig
// src/main.zig (your file - not generated)
const std = @import("std");
const User = @import("user.zig").User;
const Admin = @import("admin.zig").Admin;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    // Create a User
    var user = try User.init(allocator, "Alice", "alice@example.com");
    defer user.deinit();
    
    _ = user.authenticate("password123");
    user.set_email("newemail@example.com");
    
    // Create an Admin (inherits from User)
    var admin = try Admin.init(allocator, "Bob", "bob@example.com", "super");
    defer admin.deinit();
    
    _ = admin.authenticate("admin123");  // Inherited method
    admin.manageUsers();                 // Admin method
}
```

### Build Configuration

```zig
// build.zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});
    
    const zoop_dep = b.dependency("zoop", .{});
    const zoop = zoop_dep.module("zoop");
    
    // Add zoop codegen step
    const zoop_exe = zoop_dep.artifact("zoop-codegen");
    const zoop_step = @import("zoop").addZoopCodegenFromBinary(b, zoop_exe, .{
        .source_dir = "zoop_src",
        .output_dir = "src",
    });
    
    // Build executable
    const exe = b.addExecutable(.{
        .name = "myapp",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });
    
    exe.step.dependOn(zoop_step);  // Run codegen before build
    exe.root_module.addImport("zoop", zoop);
    
    b.installArtifact(exe);
}
```

### Workflow

1. **Edit source files:**
   ```bash
   # Edit zoop_src/user.zig - add a new field
   # Edit zoop_src/admin.zig - add a new method
   ```

2. **Build (regenerates automatically):**
   ```bash
   zig build
   # Output:
   #   Generated: user.zig
   #   Generated: admin.zig  (descendant of User)
   ```

3. **Test:**
   ```bash
   zig build test
   ```

4. **Review generated code:**
   ```bash
   git diff src/user.zig src/admin.zig
   ```

5. **Format check (REQUIRED before commit):**
   ```bash
   zig fmt --check src/ zoop_src/ tests/
   # If fails, run: zig fmt src/ zoop_src/ tests/
   ```

6. **Commit both source and generated:**
   ```bash
   git add zoop_src/ src/
   git commit -m "Add role management to Admin"
   ```

---

## Troubleshooting

### "Generated file has errors"

❌ **Wrong approach**: Edit `src/user.zig` to fix it

✅ **Correct approach**:
1. Identify the issue in `src/user.zig`
2. Find the corresponding code in `zoop_src/user.zig`
3. Fix it in the zoop source file
4. Run `zig build` to regenerate
5. Verify the fix in `src/user.zig`

### "Changes keep getting lost"

You're probably editing generated files. Check:
1. Are you editing files in `src/`? (Wrong - these are generated)
2. Edit files in `zoop_src/` instead (Correct)

### "Build is slow"

Clear the cache to verify it's working:
```bash
rm .zig-cache/zoop-manifest.json
zig build  # Should be slow (full regeneration)
zig build  # Should be fast (cache hit)
```

If second build is still slow, cache may not be enabled. Check `build.zig`.

### "Descendant not regenerating"

Cache tracks parent relationships. If inheritance chain is broken:
1. Clear cache: `zig build clean-cache`
2. Rebuild: `zig build`

---

## Summary

**Remember:**
1. ❌ NEVER edit generated files (`src/`)
2. ✅ ONLY edit zoop source files (`zoop_src/`)
3. ✅ Build automatically regenerates changed files + descendants
4. ✅ Run `zig fmt --check` before EVERY commit (REQUIRED)
5. ✅ Commit BOTH source and generated files together
6. ✅ Clear cache if things seem wrong

**Development cycle:**
Edit `zoop_src/` → `zig build` → `zig build test` → `zig fmt --check` → Review `src/` → Commit both

**When in doubt:**
- Check which directory you're editing (should be `zoop_src/`)
- Check `build.zig` to find source_dir and output_dir
- Clear cache and rebuild if something seems cached incorrectly
- Always run `zig fmt --check` before committing
